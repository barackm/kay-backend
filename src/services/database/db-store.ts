import { prisma } from "../../db/client.js";
import crypto from "crypto";
import type {
  StoredToken,
  AtlassianUser,
  AccessibleResource,
} from "../../types/oauth.js";

function hashRefreshToken(token: string): string {
  return crypto.createHash("sha256").update(token).digest("hex");
}

// Note: storeUserTokens and getUserTokens still use the old users/atlassian_tokens tables
// These are kept for Atlassian OAuth support but are separate from the core 3-table schema
// TODO: Consider migrating these to Connection metadata or a separate table
export async function storeUserTokens(
  accountId: string,
  accessToken: string,
  refreshToken: string,
  expiresIn: number,
  user: AtlassianUser,
  resources: AccessibleResource[]
): Promise<void> {
  // For now, this is a no-op as we're focusing on the core 3 tables
  // Atlassian tokens are stored in Connection metadata
}

export function getUserTokens(accountId: string): StoredToken | undefined {
  // For now, return undefined as we're not using the users/atlassian_tokens tables
  // Tokens are stored in Connection metadata
  return undefined;
}

// Store CLI session data in KaySession
export async function storeCliSession(
  sessionToken: string,
  refreshToken: string,
  accountId: string | null,
  expiresInMs: number,
  deviceInfo?: string
): Promise<void> {
  // Extract kaySessionId from JWT token
  const { verifyCliSessionToken } = await import("../auth/auth.js");
  try {
    const payload = verifyCliSessionToken(sessionToken);
    const kaySessionId = payload.kay_session_id;

    if (!kaySessionId) {
      throw new Error("Session token missing kay_session_id");
    }

    const expiresAt = new Date(Date.now() + expiresInMs);
    const hashedRefreshToken = hashRefreshToken(refreshToken);

    await prisma.kaySession.update({
      where: { id: kaySessionId },
      data: {
        refreshToken: hashedRefreshToken,
        expiresAt,
        deviceInfo: deviceInfo || null,
      },
    });
  } catch (error) {
    throw error;
  }
}

export async function getCliSessionByToken(sessionToken: string): Promise<
  | {
      refresh_token: string;
      expires_at: number;
    }
  | undefined
> {
  // Extract kaySessionId from JWT and get session
  const { verifyCliSessionToken } = await import("../auth/auth.js");
  try {
    const payload = verifyCliSessionToken(sessionToken);
    const kaySessionId = payload.kay_session_id;

    if (!kaySessionId) {
      return undefined;
    }

    const session = await prisma.kaySession.findUnique({
      where: { id: kaySessionId },
      select: { refreshToken: true, expiresAt: true },
    });

    if (!session || !session.refreshToken || !session.expiresAt) {
      return undefined;
    }

    return {
      refresh_token: session.refreshToken,
      expires_at: session.expiresAt.getTime(),
    };
  } catch {
    return undefined;
  }
}

export async function getCliSessionByRefreshToken(
  refreshToken: string
): Promise<
  | {
      session_token: string;
      expires_at: number;
      kaySessionId: string;
    }
  | undefined
> {
  const hashedToken = hashRefreshToken(refreshToken);

  // Find KaySession by refresh token
  const session = await prisma.kaySession.findFirst({
    where: { refreshToken: hashedToken },
    select: { id: true, expiresAt: true },
  });

  if (!session || !session.expiresAt) {
    return undefined;
  }

  // We need to generate a temporary session_token to return
  // The actual session_token is in the JWT, but for the refresh flow we need kaySessionId
  // So we'll return the kaySessionId and let the caller generate a new token
  return {
    session_token: "", // Will be generated by caller
    expires_at: session.expiresAt.getTime(),
    kaySessionId: session.id,
  };
}

export async function deleteCliSession(sessionToken: string): Promise<void> {
  const { verifyCliSessionToken } = await import("../auth/auth.js");
  try {
    const payload = verifyCliSessionToken(sessionToken);
    const kaySessionId = payload.kay_session_id;

    if (kaySessionId) {
      await prisma.kaySession.update({
        where: { id: kaySessionId },
        data: {
          refreshToken: null,
          expiresAt: null,
        },
      });
    }
  } catch {
    // Ignore errors
  }
}

export async function deleteCliSessionByRefreshToken(
  refreshToken: string
): Promise<void> {
  const hashedToken = hashRefreshToken(refreshToken);
  // Find session by refresh token and clear it
  await prisma.kaySession.updateMany({
    where: { refreshToken: hashedToken },
    data: {
      refreshToken: null,
      expiresAt: null,
    },
  });
}

export async function getCliSessionBySessionToken(
  sessionToken: string
): Promise<
  | {
      refresh_token: string;
      expires_at: number;
    }
  | undefined
> {
  return getCliSessionByToken(sessionToken);
}

export async function updateCliSessionToken(
  oldSessionToken: string,
  newSessionToken: string,
  newExpiresAt: number
): Promise<void> {
  // The new session token will have the same kaySessionId, so we just need to update expiresAt
  const { verifyCliSessionToken } = await import("../auth/auth.js");
  try {
    const payload = verifyCliSessionToken(newSessionToken);
    const kaySessionId = payload.kay_session_id;

    if (kaySessionId) {
      await prisma.kaySession.update({
        where: { id: kaySessionId },
        data: {
          expiresAt: new Date(newExpiresAt),
        },
      });
    }
  } catch {
    // Ignore errors
  }
}

export async function cleanupExpiredSessions(): Promise<void> {
  const now = new Date();
  await prisma.kaySession.updateMany({
    where: {
      expiresAt: {
        lt: now,
      },
    },
    data: {
      refreshToken: null,
      expiresAt: null,
    },
  });
}
