#!/usr/bin/env tsx

import { GenericMCPClient } from "../src/servers/generic-client.js";
import {
    MCP_SERVERS,
    isServerConfigured,
    getServerEnvForGeneration,
} from "../src/servers/config.js";
import * as fs from "fs/promises";
import * as path from "path";

interface ToolDefinition {
    name: string;
    description?: string;
    inputSchema: Record<string, unknown>;
}

/**
 * Convert a JSON Schema to TypeScript interface properties
 */
function jsonSchemaToTypeScript(
    schema: Record<string, unknown>,
    indent = "  "
): string {
    if (schema.type !== "object" || !schema.properties) {
        return "Record<string, unknown>";
    }

    const properties = schema.properties as Record<
        string,
        { type?: string; description?: string }
    >;
    const required = (schema.required as string[]) || [];

    const lines: string[] = [];
    for (const [key, prop] of Object.entries(properties)) {
        const isRequired = required.includes(key);
        const tsType = jsonTypeToTsType(prop.type || "unknown");
        const optional = isRequired ? "" : "?";

        if (prop.description) {
            lines.push(`${indent}/** ${prop.description} */`);
        }
        lines.push(`${indent}${key}${optional}: ${tsType};`);
    }

    return lines.join("\n");
}

/**
 * Convert JSON Schema type to TypeScript type
 */
function jsonTypeToTsType(jsonType: string): string {
    switch (jsonType) {
        case "string":
            return "string";
        case "number":
        case "integer":
            return "number";
        case "boolean":
            return "boolean";
        case "array":
            return "unknown[]";
        case "object":
            return "Record<string, unknown>";
        default:
            return "unknown";
    }
}

/**
 * Convert tool name to PascalCase for type names
 */
function toPascalCase(str: string): string {
    return str
        .split(/[-_]/)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join("");
}

/**
 * Convert tool name to camelCase for function names
 */
function toCamelCase(str: string): string {
    const pascal = toPascalCase(str);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

/**
 * Generate a TypeScript file for a single tool
 */
function generateToolFile(tool: ToolDefinition, serverName: string): string {
    const functionName = toCamelCase(tool.name);
    const inputTypeName = `${toPascalCase(tool.name)}Input`;
    const outputTypeName = `${toPascalCase(tool.name)}Output`;

    const inputProperties = jsonSchemaToTypeScript(tool.inputSchema);

    return `import { callMCPTool } from "../client.js";

export interface ${inputTypeName} {
${inputProperties}
}

export interface ${outputTypeName} {
  [key: string]: unknown;
}

/**
 * ${tool.description || tool.name}
 */
export async function ${functionName}(
  kaySessionId: string,
  input: ${inputTypeName}
): Promise<${outputTypeName}> {
  return callMCPTool<${outputTypeName}>(
    kaySessionId,
    "${serverName}",
    "${tool.name}",
    input
  );
}
`;
}

/**
 * Generate index.ts that re-exports all tools
 */
function generateIndexFile(tools: ToolDefinition[]): string {
    const exports = tools
        .map((tool) => {
            const functionName = toCamelCase(tool.name);
            return `export { ${functionName} } from "./${functionName}.js";`;
        })
        .join("\n");

    return `// Auto-generated file - do not edit manually
// Generated by scripts/generate-server-tools.ts

${exports}
`;
}

/**
 * Generate tools for a single server
 */
async function generateServerTools(
    serverName: string,
    npmPackage: string,
    env: Record<string, string>
): Promise<void> {
    console.log(`\nðŸ”§ Generating tools for ${serverName}...`);

    const client = new GenericMCPClient();

    try {
        await client.initialize(npmPackage, env);
        const tools = client.getTools();

        console.log(`   Found ${tools.length} tools`);

        const serverDir = path.join(process.cwd(), "src", "servers", serverName);

        // Create server directory
        await fs.mkdir(serverDir, { recursive: true });

        // Generate individual tool files
        for (const tool of tools) {
            const functionName = toCamelCase(tool.name);
            const filePath = path.join(serverDir, `${functionName}.ts`);
            const content = generateToolFile(tool, serverName);

            await fs.writeFile(filePath, content, "utf-8");
            console.log(`   âœ“ ${functionName}.ts`);
        }

        // Generate index.ts
        const indexPath = path.join(serverDir, "index.ts");
        const indexContent = generateIndexFile(tools);
        await fs.writeFile(indexPath, indexContent, "utf-8");
        console.log(`   âœ“ index.ts`);

        await client.disconnect();
        console.log(`   âœ… ${serverName} complete`);
    } catch (error) {
        console.error(
            `   âŒ Failed to generate ${serverName} tools:`,
            error instanceof Error ? error.message : error
        );
    }
}

/**
 * Main execution
 */
async function main() {
    console.log("ðŸš€ MCP Server Tool Generator");
    console.log("================================\n");

    const configuredServers = MCP_SERVERS.filter((config) => {
        const configured = isServerConfigured(config);
        if (!configured) {
            const missing = config.envVars.required.filter((v) => !process.env[v]);
            console.log(`âš ï¸  Skipping ${config.name} (missing: ${missing.join(", ")})`);
        }
        return configured;
    });

    if (configuredServers.length === 0) {
        console.error("\nâŒ No servers configured. Please set environment variables.");
        console.error("\nConfigured servers:");
        for (const config of MCP_SERVERS) {
            console.error(`\n${config.name}:`);
            console.error(`  Required: ${config.envVars.required.join(", ")}`);
            if (config.envVars.optional) {
                console.error(`  Optional: ${config.envVars.optional.join(", ")}`);
            }
        }
        process.exit(1);
    }

    // Generate tools for each configured server
    for (const config of configuredServers) {
        const env = getServerEnvForGeneration(config);
        await generateServerTools(config.name, config.npmPackage, env);
    }

    console.log("\nâœ¨ Tool generation complete!");
}

main().catch((error) => {
    console.error("Fatal error:", error);
    process.exit(1);
});
